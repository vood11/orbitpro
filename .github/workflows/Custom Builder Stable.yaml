steps:
  - name: Initialize Environment
    run: |
      echo "ðŸš€ Initializing build environment..."
      sudo timedatectl set-timezone "$TZ"
      mkdir -p workspace
      df -hT
      ulimit -n 8192
      sudo sysctl vm.swappiness=10
      echo "Environment initialized successfully"

  - name: Maximize Build Space
    uses: easimon/maximize-build-space@master
    with:
      root-reserve-mb: '4096'
      temp-reserve-mb: '2048'
      swap-size-mb: '2048'
      remove-dotnet: 'true'
      remove-android: 'true'
      remove-haskell: 'true'
      remove-codeql: 'true'
      remove-docker-images: 'true'

  - name: Checkout Repository
    uses: actions/checkout@v4

  - name: Install Dependencies
    env:
      DEBIAN_FRONTEND: noninteractive
    run: |
      echo "ðŸ“¦ Installing build dependencies..."
      sudo -E apt-get -qq update
      sudo -E apt-get -qq install -y \
        ack antlr3 aria2 autoconf automake autopoint binutils bison \
        btrfs-progs build-essential bzip2 ca-certificates ccache cmake coreutils \
        cpio curl device-tree-compiler fastjar flex g++-multilib gawk gcc-multilib \
        gettext git git-core gperf gzip haveged intltool jq libc6-dev-i386 \
        libelf-dev libfuse-dev libglib2.0-dev libgmp3-dev libltdl-dev libmpc-dev \
        libmpfr-dev libncurses5-dev libncursesw5-dev libpython3-dev libreadline-dev \
        libssl-dev libtool libz-dev lrzsz mkisofs msmtp nano ninja-build p7zip \
        p7zip-full patch pigz pkgconf python3 python3-pip python3-pyelftools \
        python3-setuptools qemu-utils rsync scons squashfs-tools swig tar \
        uglifyjs unzip upx upx-ucl vim wget xxd xz-utils yasm zip \
        zlib1g-dev zstd
      sudo -E apt-get -qq autoremove --purge
      sudo -E apt-get -qq clean
      df -hT
      echo "Dependencies installed successfully"

  - name: Download Source Code
    id: clone
    run: |
      echo "ðŸ“¥ Downloading OpenWrt source code..."
      cd workspace
      
      # Check if branch starts with 'v' (version tag)
      if [[ "$SOURCE_BRANCH" =~ ^v[0-9] ]]; then
        echo "Downloading version tag $SOURCE_BRANCH as ZIP archive"
        retry_count=0
        until curl -fsSL "${SOURCE_URL}/archive/refs/tags/${SOURCE_BRANCH}.zip" -o openwrt.zip || [ $retry_count -ge $MAX_RETRIES ]; do
          retry_count=$((retry_count+1))
          echo "Download failed, retrying in $RETRY_DELAY seconds... ($retry_count/$MAX_RETRIES)"
          sleep $RETRY_DELAY
        done
        
        if [ ! -f "openwrt.zip" ]; then
          echo "Failed to download archive after $MAX_RETRIES attempts"
          exit 1
        fi
        
        unzip -q openwrt.zip
        mv openwrt-* openwrt
        rm openwrt.zip
      else
        echo "Cloning branch $SOURCE_BRANCH"
        retry_count=0
        until git clone --single-branch $SOURCE_URL -b $SOURCE_BRANCH openwrt || [ $retry_count -ge $MAX_RETRIES ]; do
          retry_count=$((retry_count+1))
          echo "Clone failed, retrying in $RETRY_DELAY seconds... ($retry_count/$MAX_RETRIES)"
          sleep $RETRY_DELAY
          rm -rf openwrt
        done
        
        if [ ! -d "openwrt" ]; then
          echo "Failed to clone repository after $MAX_RETRIES attempts"
          exit 1
        fi
      fi
      
      cd openwrt
      git config --global user.name "github-actions"
      git config --global user.email "github-actions@github.com"
      
      OPENWRT_ROOT_PATH="$PWD"
      echo "OPENWRT_ROOT_PATH=$OPENWRT_ROOT_PATH" >> $GITHUB_ENV
      echo "OPENWRT_ROOT_PATH=$OPENWRT_ROOT_PATH" >> $GITHUB_OUTPUT
      echo "Source code downloaded to: $OPENWRT_ROOT_PATH"

  - name: Apply Custom Patches
    run: |
      echo "ðŸ”§ Applying custom patches..."
      cd $OPENWRT_ROOT_PATH
      
      # Extract version from SOURCE_BRANCH for patch matching
      VERSION_PREFIX=$(echo "$SOURCE_BRANCH" | sed 's/\.[^.]*$//')
      PATCH_FILE="../patch/${VERSION_PREFIX}.patch"
      
      if [ -f "$PATCH_FILE" ]; then
        echo "Applying patch: $PATCH_FILE"
        git apply "$PATCH_FILE" || echo "Patch application failed or not needed"
      else
        echo "No patch file found for version: $VERSION_PREFIX"
      fi

  - name: Load Configuration & Extract Variables
    id: env
    run: |
      echo "âš™ï¸ Loading configuration and extracting variables..."
      
      # Load configuration file
      if [[ "$CONFIG_LINK" == "true" && -n "$CONFIG_URL" ]]; then
        echo "Downloading configuration from URL: $CONFIG_URL"
        curl -fsSL "$CONFIG_URL" -o "$OPENWRT_ROOT_PATH/.config"
      else
        echo "Using local configuration file: $CONFIG_FILE"
        cp "./config/$CONFIG_FILE" "$OPENWRT_ROOT_PATH/.config"
      fi
      
      cd $OPENWRT_ROOT_PATH
      make defconfig
      
      # Extract variables from config
      DEVICE_NAME=$(grep 'CONFIG_TARGET.*DEVICE.*=y' .config | sed -r 's/.*DEVICE_(.*)=y/\1/' | head -n1)
      DEVICE_TARGET=$(grep 'CONFIG_TARGET_BOARD' .config | awk -F '"' '{print $2}')
      DEVICE_SUBTARGET=$(grep 'CONFIG_TARGET_SUBTARGET' .config | awk -F '"' '{print $2}')
      SOURCE_OWNER=$(echo $SOURCE_URL | awk -F '/' '{print $(NF-1)}')
      SOURCE_REPO=$(echo $SOURCE_URL | awk -F '/' '{print $NF}' | sed 's/\.git$//')
      
      # Generate toolchain image name
      TOOLCHAIN_IMAGE="toolchain-$SOURCE_OWNER-$SOURCE_REPO-$SOURCE_BRANCH-$DEVICE_TARGET-$DEVICE_SUBTARGET"
      BUILD_DATE=$(date +"%Y-%m-%d-%H%M")
      FIRMWARE_NAME="${SOURCE_BRANCH}_${DEVICE_NAME}"
      
      # Export variables
      echo "DEVICE_NAME=$DEVICE_NAME" >> $GITHUB_ENV
      echo "DEVICE_NAME=$DEVICE_NAME" >> $GITHUB_OUTPUT
      echo "DEVICE_TARGET=$DEVICE_TARGET" >> $GITHUB_ENV  
      echo "DEVICE_TARGET=$DEVICE_TARGET" >> $GITHUB_OUTPUT
      echo "DEVICE_SUBTARGET=$DEVICE_SUBTARGET" >> $GITHUB_ENV
      echo "DEVICE_SUBTARGET=$DEVICE_SUBTARGET" >> $GITHUB_OUTPUT
      echo "TOOLCHAIN_IMAGE=$TOOLCHAIN_IMAGE" >> $GITHUB_ENV
      echo "TOOLCHAIN_IMAGE=$TOOLCHAIN_IMAGE" >> $GITHUB_OUTPUT
      echo "BUILD_DATE=$BUILD_DATE" >> $GITHUB_ENV
      echo "BUILD_DATE=$BUILD_DATE" >> $GITHUB_OUTPUT
      echo "FIRMWARE_NAME=$FIRMWARE_NAME" >> $GITHUB_ENV
      echo "FIRMWARE_NAME=$FIRMWARE_NAME" >> $GITHUB_OUTPUT
      
      echo "âœ… Variables extracted:"
      echo "  Device: $DEVICE_NAME"
      echo "  Target: $DEVICE_TARGET/$DEVICE_SUBTARGET" 
      echo "  Toolchain Image: $TOOLCHAIN_IMAGE"
      echo "  Firmware Name: $FIRMWARE_NAME"

  - name: Get Existing Toolchain Hash
    id: get_hash
    continue-on-error: true
    uses: robinraju/release-downloader@v1.12
    with:
      token: ${{ env.TOKEN }}
      repository: ${{ github.repository }}
      fileName: ${{ env.TOOLCHAIN_IMAGE }}.hash
      tag: ${{ env.TOOLCHAIN_TAG }}

  - name: Compare Toolchain Hash
    id: hash_check
    run: |
      echo "ðŸ” Checking toolchain rebuild requirements..."
      
      if [ "$DISABLE_COMPILE_TOOLCHAIN" == "true" ]; then
        echo "REBUILD_TOOLCHAIN=false" >> $GITHUB_ENV
        echo "SKIP_TOOLCHAIN=true" >> $GITHUB_ENV
        echo "âœ… Toolchain compilation disabled by user input"
        exit 0
      fi
      
      cd $OPENWRT_ROOT_PATH
      CURRENT_HASH=$(git log --pretty=tformat:"%H" -n1 tools toolchain 2>/dev/null || echo "")
      echo "CURRENT_HASH=$CURRENT_HASH" >> $GITHUB_ENV
      
      if [ -f "$TOOLCHAIN_IMAGE.hash" ]; then
        RELEASE_HASH=$(cat "$TOOLCHAIN_IMAGE.hash")
        echo "ðŸ“‹ Found existing toolchain hash: $RELEASE_HASH"
        echo "ðŸ“‹ Current toolchain hash: $CURRENT_HASH"
      else
        RELEASE_HASH=""
        echo "ðŸ“‹ No existing toolchain hash found"
      fi
      
      # Determine if rebuild is needed
      if [ -z "$RELEASE_HASH" ] || [ "$CURRENT_HASH" != "$RELEASE_HASH" ] || [ "$TOOLCHAIN_REBUILD" == "true" ]; then
        echo "REBUILD_TOOLCHAIN=true" >> $GITHUB_ENV
        echo "SKIP_TOOLCHAIN=false" >> $GITHUB_ENV
        echo "ðŸ”„ Toolchain rebuild required"
      else
        echo "REBUILD_TOOLCHAIN=false" >> $GITHUB_ENV  
        echo "SKIP_TOOLCHAIN=false" >> $GITHUB_ENV
        echo "âœ… Using existing toolchain"
      fi

  - name: Install Feeds (for Toolchain)
    if: env.REBUILD_TOOLCHAIN == 'true'
    run: |
      echo "ðŸ“¦ Installing feeds for toolchain build..."
      cd $OPENWRT_ROOT_PATH
      ./scripts/feeds clean
      ./scripts/feeds update -a
      ./scripts/feeds install -a

  - name: Compile Tools
    if: env.REBUILD_TOOLCHAIN == 'true'
    timeout-minutes: 60
    run: |
      echo "ðŸ”¨ Compiling tools..."
      cd $OPENWRT_ROOT_PATH
      echo "Using $(nproc) threads for compilation"
      make tools/compile -j$(($(nproc) + 1)) || make tools/compile -j1 V=s
      echo "âœ… Tools compilation completed"

  - name: Compile Toolchain
    if: env.REBUILD_TOOLCHAIN == 'true'
    timeout-minutes: 120
    run: |
      echo "ðŸ”¨ Compiling toolchain..."
      cd $OPENWRT_ROOT_PATH
      echo "Using $(nproc) threads for compilation"
      make toolchain/compile -j$(($(nproc) + 1)) || make toolchain/compile -j1 V=s
      echo "âœ… Toolchain compilation completed"

  - name: Create & Upload Toolchain Cache
    if: env.REBUILD_TOOLCHAIN == 'true'
    run: |
      echo "ðŸ“¦ Creating toolchain cache..."
      cd workspace
      
      # Clean unnecessary files before creating image
      cd openwrt
      rm -rf .config* dl bin
      cd ..
      
      # Create single SquashFS image
      echo "Creating SquashFS image: $TOOLCHAIN_IMAGE.img"
      mksquashfs openwrt "$TOOLCHAIN_IMAGE.img" \
        -force-gid 1001 -force-uid 1001 \
        -comp zstd -Xcompression-level 19
      
      # Prepare output directory
      mkdir -p "$GITHUB_WORKSPACE/output"
      mv "$TOOLCHAIN_IMAGE.img" "$GITHUB_WORKSPACE/output/"
      
      # Create hash file
      cd $OPENWRT_ROOT_PATH  
      echo "$CURRENT_HASH" > "$GITHUB_WORKSPACE/output/$TOOLCHAIN_IMAGE.hash"
      
      ls -lh "$GITHUB_WORKSPACE/output"
      echo "âœ… Toolchain cache created successfully"

  - name: Delete Old Toolchain Assets
    if: env.REBUILD_TOOLCHAIN == 'true'
    uses: mknejp/delete-release-assets@v1
    with:
      token: ${{ env.TOKEN }}
      tag: ${{ env.TOOLCHAIN_TAG }}
      assets: ${{ env.TOOLCHAIN_IMAGE }}.*
      fail-if-no-assets: false
      fail-if-no-release: false

  - name: Upload Toolchain to Release
    if: env.REBUILD_TOOLCHAIN == 'true'
    uses: ncipollo/release-action@v1
    with:
      token: ${{ env.TOKEN }}
      name: toolchain-cache
      tag: ${{ env.TOOLCHAIN_TAG }}
      artifacts: output/*
      replacesArtifacts: true
      allowUpdates: true
      prerelease: true

  - name: Download Toolchain Cache
    if: env.REBUILD_TOOLCHAIN == 'false' && env.DISABLE_COMPILE_TOOLCHAIN == 'false'
    uses: robinraju/release-downloader@v1.12
    with:
      token: ${{ env.TOKEN }}
      repository: ${{ github.repository }}
      fileName: ${{ env.TOOLCHAIN_IMAGE }}.img
      tag: ${{ env.TOOLCHAIN_TAG }}
      out-file-path: workspace

  - name: Prepare Toolchain from Cache  
    if: env.REBUILD_TOOLCHAIN == 'false' && env.DISABLE_COMPILE_TOOLCHAIN == 'false'
    run: |
      echo "ðŸ“‚ Preparing toolchain from cache..."
      cd workspace
      
      # Create mount directories
      mkdir -p openwrt-ro openwrt workdir overlay
      
      # Mount the single toolchain image
      sudo mount -o loop "$TOOLCHAIN_IMAGE.img" openwrt-ro
      sudo mount -t overlay overlay \
        -o lowerdir=openwrt-ro,upperdir=overlay,workdir=workdir \
        openwrt
      
      echo "âœ… Toolchain cache mounted successfully"

  - name: Update Feeds
    run: |
      echo "ðŸ“¦ Updating and installing feeds..."
      cd $OPENWRT_ROOT_PATH
      
      # Load custom feeds if script exists
      if [ -f "../scripts/feeds.sh" ]; then
        cp "../scripts/feeds.sh" ./
        chmod +x feeds.sh && ./feeds.sh
      fi
      
      ./scripts/feeds clean
      ./scripts/feeds update -a
      
      # Install custom packages if script exists  
      if [ -f "../scripts/feeds_pkg.sh" ]; then
        cp "../scripts/feeds_pkg.sh" ./
        chmod +x feeds_pkg.sh && ./feeds_pkg.sh
        ./scripts/feeds update -a
      fi
      
      ./scripts/feeds install -a
      echo "âœ… Feeds updated successfully"

  - name: Load Final Configuration
    run: |
      echo "âš™ï¸ Loading final configuration..."
      
      if [[ "$CONFIG_LINK" == "true" && -n "$CONFIG_URL" ]]; then
        curl -fsSL "$CONFIG_URL" -o "$OPENWRT_ROOT_PATH/.config"
      else
        cp "./config/$CONFIG_FILE" "$OPENWRT_ROOT_PATH/.config"
      fi
      
      cd $OPENWRT_ROOT_PATH
      make defconfig
      echo "âœ… Final configuration loaded"

  - name: Apply DIY Script
    run: |
      echo "ðŸ”§ Applying DIY customizations..."
      cd $OPENWRT_ROOT_PATH
      
      if [ -f "../scripts/$DIY_SH" ]; then
        cp "../scripts/$DIY_SH" ./diy.sh
        chmod +x diy.sh && ./diy.sh
        echo "âœ… DIY script applied: $DIY_SH"
      else
        echo "No DIY script found: $DIY_SH"
      fi

  - name: Replace Vermagic
    if: env.VERMAGIC == 'true'
    run: |
      echo "ðŸ”„ Replacing kernel vermagic..."
      
      snapshot_version="${SOURCE_BRANCH#*-}"
      if [[ "$SOURCE_BRANCH" =~ ^v[0-9] ]]; then
        snapshot_version="${SOURCE_BRANCH#v}"
        snapshot_version="${snapshot_version%.*}"
      fi
      
      if [[ "$VERMAGIC_OPT" == "true" ]]; then
        version="${snapshot_version}-SNAPSHOT"
      else
        # Try to get the latest release version
        release_version=$(curl -s https://api.github.com/repos/openwrt/openwrt/tags \
          | grep -m1 -oE "\"name\":\\s*\"v${snapshot_version}\\.[^\"]+\"" \
          | cut -d'"' -f4 | sed 's/^v//' || echo "${snapshot_version}.0")
        version="${release_version}"
      fi
      
      echo "Using vermagic version: $version"
      
      # Download and replace vermagic if possible
      vermagic_url="https://downloads.openwrt.org/releases/${version}/targets/${DEVICE_TARGET}/${DEVICE_SUBTARGET}/kmods/"
      
      if curl -s "$vermagic_url" > /dev/null 2>&1; then
        vermagic=$(curl -s "$vermagic_url" | grep -oP '\d+\.\d+\.\d+-\d+-[a-z0-9]{16}' | head -n1)
        if [ -n "$vermagic" ]; then
          echo "Replacing vermagic with: $vermagic"
          find staging_dir -name "vermagic" -exec sh -c 'echo "$1" > "$2"' _ "$vermagic" {} \; 2>/dev/null || true
        fi
      fi

  - name: Download Packages
    run: |
      echo "ðŸ“¥ Downloading packages..."
      cd $OPENWRT_ROOT_PATH
      make download -j8 || make download -j1 V=s
      find dl -size -1024c -exec ls -l {} \;
      find dl -size -1024c -exec rm -f {} \;

  - name: Compile Packages  
    timeout-minutes: 180
    run: |
      echo "ðŸ”¨ Compiling packages..."
      cd $OPENWRT_ROOT_PATH
      echo "Using $(nproc) threads for compilation"
      make package/compile -j$(($(nproc) + 1)) || make package/compile -j1 V=s
      echo "âœ… Packages compilation completed"

  - name: Compile Target
    timeout-minutes: 60
    run: |
      echo "ðŸ”¨ Compiling target..."
      cd $OPENWRT_ROOT_PATH
      make target/install -j$(($(nproc) + 1)) || make target/install -j1 V=s
      make checksum
      echo "âœ… Target compilation completed"

  - name: Check Space Usage
    run: |
      echo "ðŸ’¾ Checking space usage..."
      df -hT
      du -h --max-depth=1 workspace/ | sort -hr

  - name: Upload Bin Directory
    uses: actions/upload-artifact@v4
    with:
      name: openwrt-bin-${{ env.FIRMWARE_NAME }}
      path: workspace/openwrt/bin/
      retention-days: 7

  - name: Organize Firmware Files
    id: organize
    run: |
      echo "ðŸ“ Organizing firmware files..."
      cd $OPENWRT_ROOT_PATH/bin/targets/*/*
      
      # Remove unnecessary files
      rm -rf packages
      
      # Create release directory
      mkdir -p release
      
      # Move firmware files
      for ext in bin img gz; do
        find . -name "*.$ext" -exec mv {} release/ \; 2>/dev/null || true
      done
      
      # Move other important files
      find . -name "*.manifest" -exec mv {} release/ \; 2>/dev/null || true
      find . -name "sha256sums" -exec mv {} release/ \; 2>/dev/null || true
      
      ls -la release/
      echo "RELEASE_PATH=$PWD/release" >> $GITHUB_ENV
      echo "âœ… Firmware files organized"

  - name: Upload Firmware to Release
    if: env.FIRMWARE_RELEASE == 'true'
    uses: ncipollo/release-action@v1
    with:
      token: ${{ env.TOKEN }}
      name: OpenWrt Firmware ${{ env.FIRMWARE_NAME }}
      tag: ${{ env.FIRMWARE_NAME }}
      artifacts: ${{ env.RELEASE_PATH }}/*
      replacesArtifacts: true
      allowUpdates: true
      body: |
        ## OpenWrt Firmware Build
        
        **Build Information:**
        - Source: ${{ env.SOURCE_URL }}
        - Branch/Tag: ${{ env.SOURCE_BRANCH }}  
        - Device: ${{ env.DEVICE_NAME }}
        - Target: ${{ env.DEVICE_TARGET }}/${{ env.DEVICE_SUBTARGET }}
        - Configuration: ${{ env.CONFIG_FILE }}
        - Build Date: ${{ env.BUILD_DATE }}
        
        **Features:**
        - DIY Script: ${{ env.DIY_SH }}
        - Vermagic Replaced: ${{ env.VERMAGIC }}
        - Toolchain Rebuilt: ${{ env.REBUILD_TOOLCHAIN }}
        
        ---
        *This firmware was built automatically using GitHub Actions*

  - name: Cleanup
    if: always()
    run: |
      echo "ðŸ§¹ Cleaning up..."
      cd workspace
      
      # Cleanup mount points
      sudo umount openwrt 2>/dev/null || true
      sudo umount openwrt-ro 2>/dev/null || true
      
      # Remove large directories
      rm -rf openwrt/build_dir 2>/dev/null || true
      rm -rf openwrt/staging_dir 2>/dev/null || true
      rm -rf *.img* 2>/dev/null || true
      
      df -hT
      echo "âœ… Cleanup completed"
